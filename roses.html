<!DOCTYPE html>
<html>
<head>
    <title>Rose Bouquet</title>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-32H67JBWDE"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-32H67JBWDE');
    </script>
    <style>
        body { margin: 0; background: #fdf2f8; }
        canvas { display: block; }
        #zoomSlider {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 150px;
            opacity: 0.6;
            transition: opacity 0.2s;
            z-index: 5;
        }
        #zoomSlider:hover {
            opacity: 1;
        }
        #zoomSlider input {
            width: 100%;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="zoomSlider">
        <input type="range" id="zoom" min="2" max="10" step="0.1" value="7">
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xfdf2f8);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);


        let cameraDistance = 4;
        let cameraX = cameraDistance;
        let cameraY = -cameraDistance;
        let cameraZ = cameraDistance;
        camera.position.set(cameraX, cameraY, cameraZ);
        camera.lookAt(0, 0, 0);

        const zoomSlider = document.getElementById('zoom');
        zoomSlider.addEventListener('input', (e) => {
            cameraDistance = 12 - parseFloat(e.target.value);
            camera.position.set(
                (cameraX / Math.abs(cameraX)) * cameraDistance,
                (cameraY / Math.abs(cameraY)) * cameraDistance,
                (cameraZ / Math.abs(cameraZ)) * cameraDistance
            );
            camera.lookAt(0, 0, 0);
        });

        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
        mainLight.position.set(1, 2, 1);
        scene.add(mainLight);
        
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
        fillLight.position.set(-1, -1, 1);
        scene.add(fillLight);
        
        const sideLight = new THREE.DirectionalLight(0xffffff, 0.4);
        sideLight.position.set(2, 0, -1);
        scene.add(sideLight);

        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = {
                x: e.clientX,
                y: e.clientY
            };
        });

        document.addEventListener('mousemove', (e) => {
            if(!isDragging) return;
            const deltaMove = {
                x: e.clientX - previousMousePosition.x,
                y: e.clientY - previousMousePosition.y
            };
            const rotationSpeed = 0.005;
            scene.rotation.y += deltaMove.x * rotationSpeed;
            scene.rotation.x += deltaMove.y * rotationSpeed;
            previousMousePosition = {
                x: e.clientX,
                y: e.clientY
            };
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        function meshgrid(x, y) {
            const X = [];
            const Y = [];
            for(let i = 0; i < y.length; i++) {
                const row_x = [];
                const row_y = [];
                for(let j = 0; j < x.length; j++) {
                    row_x.push(x[j]);
                    row_y.push(y[i]);
                }
                X.push(row_x);
                Y.push(row_y);
            }
            return [X, Y];
        }

        function createStem(startPoint) {
            const curve = new THREE.CubicBezierCurve3(
                new THREE.Vector3(startPoint.x, startPoint.y, 0.5), 
                new THREE.Vector3(startPoint.x * 0.6, startPoint.y * 0.6, -0.8), 
                new THREE.Vector3(startPoint.x * 0.3, startPoint.y * 0.3, -1.5), 
                new THREE.Vector3(0, 0, -2) 
            );

            const points = curve.getPoints(50);
            const geometry = new THREE.TubeGeometry(
                new THREE.CatmullRomCurve3(points),
                50, 
                0.02, 
                8, 
                false 
            );

            const material = new THREE.MeshPhongMaterial({
                color: 0x587E7E, 
                shininess: 30
            });

            return new THREE.Mesh(geometry, material);
        }

        function createRoseSurface() {
            const x = Array.from({length: 25}, (_, i) => i / 24);
            const t = Array.from({length: 1151}, (_, i) => (i * 0.5 / 575) * 20 * Math.PI + 4 * Math.PI);
            
            const [xr, tr] = meshgrid(x, t);
            const rows = tr.length;
            const cols = tr[0].length;

            const pr = tr.map(row => row.map(t => (Math.PI/2) * Math.exp(-t/(8*Math.PI))));
            const cr = tr.map(row => row.map(t => Math.sin(15*t)/150));
            
            const ur = tr.map((row, i) => row.map((t, j) => {
                const mod_term = (3.6 * t) % (2 * Math.PI);
                return 1 - Math.pow(1 - mod_term/Math.PI, 4)/2 + cr[i][j];
            }));

            const yr = xr.map((row, i) => row.map((x, j) => 
                2 * Math.pow(x*x - x, 2) * Math.sin(pr[i][j])
            ));

            const rr = xr.map((row, i) => row.map((x, j) => 
                ur[i][j] * (x * Math.sin(pr[i][j]) + yr[i][j] * Math.cos(pr[i][j]))
            ));

            const hr = xr.map((row, i) => row.map((x, j) => 
                ur[i][j] * (x * Math.cos(pr[i][j]) - yr[i][j] * Math.sin(pr[i][j]))
            ));

            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            let indices = [];
            let index = 0;

            const colorList = [
                [0.32, 0.02, 0.04],   // deep burgundy (base / shadow)
                [0.52, 0.05, 0.06],   // wine red
                [0.72, 0.10, 0.10],   // dark rose
                [0.88, 0.18, 0.16],   // classic rose red
                [0.96, 0.28, 0.24],   // bright red
                [0.99, 0.45, 0.40],   // soft pink-red (edges / highlights)
                [1.0, 0.55, 0.50]     // petal edge highlight
            ];

            let minH = Math.min(...hr.map(row => Math.min(...row)));
            let maxH = Math.max(...hr.map(row => Math.max(...row)));

            for(let i = 0; i < rows - 1; i++) {
                for(let j = 0; j < cols - 1; j++) {
                    const x1 = rr[i][j] * Math.cos(tr[i][j]);
                    const y1 = rr[i][j] * Math.sin(tr[i][j]);
                    const z1 = hr[i][j] + 0.35;

                    const x2 = rr[i+1][j] * Math.cos(tr[i+1][j]);
                    const y2 = rr[i+1][j] * Math.sin(tr[i+1][j]);
                    const z2 = hr[i+1][j] + 0.35;

                    const x3 = rr[i][j+1] * Math.cos(tr[i][j+1]);
                    const y3 = rr[i][j+1] * Math.sin(tr[i][j+1]);
                    const z3 = hr[i][j+1] + 0.35;

                    vertices.push(x1, y1, z1, x2, y2, z2, x3, y3, z3);
                    indices.push(index, index + 1, index + 2);
                    index += 3;

                    [hr[i][j], hr[i+1][j], hr[i][j+1]].forEach(h => {
                        const t = (h - minH) / (maxH - minH);
                        const colorIndex = Math.min(Math.floor(t * (colorList.length - 1)), colorList.length - 2);
                        const colorT = (t * (colorList.length - 1)) - colorIndex;
                        
                        const color1 = colorList[colorIndex];
                        const color2 = colorList[colorIndex + 1];
                        
                        colors.push(
                            color1[0] * (1 - colorT) + color2[0] * colorT,
                            color1[1] * (1 - colorT) + color2[1] * colorT,
                            color1[2] * (1 - colorT) + color2[2] * colorT
                        );
                    });

                    const x4 = rr[i+1][j+1] * Math.cos(tr[i+1][j+1]);
                    const y4 = rr[i+1][j+1] * Math.sin(tr[i+1][j+1]);
                    const z4 = hr[i+1][j+1] + 0.35;

                    vertices.push(x2, y2, z2, x4, y4, z4, x3, y3, z3);
                    indices.push(index, index + 1, index + 2);
                    index += 3;

                    [hr[i+1][j], hr[i+1][j+1], hr[i][j+1]].forEach(h => {
                        const t = (h - minH) / (maxH - minH);
                        const colorIndex = Math.min(Math.floor(t * (colorList.length - 1)), colorList.length - 2);
                        const colorT = (t * (colorList.length - 1)) - colorIndex;
                        
                        const color1 = colorList[colorIndex];
                        const color2 = colorList[colorIndex + 1];
                        
                        colors.push(
                            color1[0] * (1 - colorT) + color2[0] * colorT,
                            color1[1] * (1 - colorT) + color2[1] * colorT,
                            color1[2] * (1 - colorT) + color2[2] * colorT
                        );
                    });
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);
            geometry.computeVertexNormals();

            const material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                side: THREE.DoubleSide,
                shininess: 50,
                transparent: true,
                opacity: 0.9
            });

            return new THREE.Mesh(geometry, material);
        }

        function createBouquet() {
            const bouquetGroup = new THREE.Group();

            const positions = [
                { x: 0, y: 0, z: 0, scale: 1.0 },      // Center
                { x: 0.8, y: 0, z: 0, scale: 0.95 },   // Right
                { x: -0.8, y: 0, z: 0, scale: 0.95 },  // Left
                { x: 0.4, y: 0.7, z: 0, scale: 0.95 }, // Top right
                { x: -0.3, y: 0.8, z: 0, scale: 0.95 },   // Top
                { x: 0.4, y: -0.7, z: 0, scale: 0.95 }, // Bottom right
                { x: -0.4, y: -0.7, z: 0, scale: 0.95 } // Bottom left
            ];

            positions.forEach((pos) => {
                const rose = createRoseSurface();
                rose.position.set(pos.x, pos.y, pos.z);
                rose.scale.set(pos.scale, pos.scale, pos.scale);

                if (pos.x !== 0 || pos.y !== 0) {
                    const angleToCenter = Math.atan2(pos.y, pos.x);
                    const tiltAmount = 0.3;
                    rose.rotation.x = -pos.y * tiltAmount / Math.sqrt(pos.x * pos.x + pos.y * pos.y);
                    rose.rotation.y = pos.x * tiltAmount / Math.sqrt(pos.x * pos.x + pos.y * pos.y);
                }

                const stem = createStem(pos);
                
                bouquetGroup.add(rose);
                bouquetGroup.add(stem);
            });

            return bouquetGroup;
        }

        const bouquet = createBouquet();
        scene.add(bouquet);

        camera.position.set(4, -4, 4);
        camera.lookAt(0, 0, 0);

        

        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = {
                x: e.clientX,
                y: e.clientY
            };
        });

        document.addEventListener('mousemove', (e) => {
            if(!isDragging) return;
            const deltaMove = {
                x: e.clientX - previousMousePosition.x,
                y: e.clientY - previousMousePosition.y
            };
            const rotationSpeed = 0.005;
            scene.rotation.y += deltaMove.x * rotationSpeed;
            scene.rotation.x += deltaMove.y * rotationSpeed;
            previousMousePosition = {
                x: e.clientX,
                y: e.clientY
            };
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        function animate() {
            requestAnimationFrame(animate);
            
            // Add ambient rotation to the bouquet
            if (!isDragging) {
                bouquet.rotation.y += 0.003; // Slow ambient rotation around Y-axis
            }
            
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>